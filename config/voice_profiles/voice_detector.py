#!/usr/bin/env python3
"""
Voice Profile Detector
=====================

Detects which voice profile matches a given piece of content.
Helps ensure content doesn't look AI-generated by matching to authentic human voices.

Author: Agent-5 (Business Intelligence Specialist)
"""

import yaml
import re
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from collections import Counter


class VoiceDetector:
    """Detects which voice profile matches content."""
    
    def __init__(self, profiles_dir: Optional[Path] = None):
        """Initialize with voice profiles directory."""
        if profiles_dir is None:
            profiles_dir = Path(__file__).parent
        
        self.profiles_dir = profiles_dir
        self.profiles: Dict[str, Dict] = {}
        self._load_profiles()
    
    def _load_profiles(self) -> None:
        """Load all voice profiles from directory."""
        if not self.profiles_dir.exists():
            print(f"‚ö†Ô∏è  Profiles directory not found: {self.profiles_dir}")
            return
        
        for profile_file in self.profiles_dir.glob("*_voice_profile.yaml"):
            try:
                with open(profile_file, 'r', encoding='utf-8') as f:
                    profile = yaml.safe_load(f)
                    if profile and 'voice_profile' in profile:
                        profile_id = profile['voice_profile'].get('id', profile_file.stem)
                        self.profiles[profile_id] = profile['voice_profile']
                        print(f"‚úÖ Loaded profile: {profile_id}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Could not load {profile_file}: {e}")
    
    def detect_voice(self, content: str) -> Tuple[str, float, Dict]:
        """
        Detect which voice profile matches the content.
        
        Returns:
            (profile_id, confidence_score, analysis_details)
        """
        if not self.profiles:
            return ("unknown", 0.0, {"error": "No profiles loaded"})
        
        scores = {}
        analyses = {}
        
        for profile_id, profile in self.profiles.items():
            score, analysis = self._analyze_match(content, profile)
            scores[profile_id] = score
            analyses[profile_id] = analysis
        
        # Find best match
        best_profile = max(scores.items(), key=lambda x: x[1])
        profile_id, confidence = best_profile
        
        return (profile_id, confidence, analyses[profile_id])
    
    def _analyze_match(self, content: str, profile: Dict) -> Tuple[float, Dict]:
        """
        Analyze how well content matches a profile.
        
        Returns:
            (score, analysis_details)
        """
        score = 0.0
        max_score = 0.0
        matches = []
        
        content_lower = content.lower()
        
        # Check unique voice markers
        markers = profile.get('unique_voice_markers', [])
        if markers:
            max_score += len(markers) * 2
            for marker in markers:
                if marker.lower() in content_lower:
                    score += 2
                    matches.append(f"marker: {marker}")
        
        # Check opening styles
        openings = profile.get('opening_styles', [])
        if openings:
            max_score += len(openings) * 1.5
            for opening in openings:
                # Extract base pattern (remove placeholders)
                pattern = opening.split('[')[0].strip().lower()
                if pattern and pattern in content_lower[:200]:  # Check first 200 chars
                    score += 1.5
                    matches.append(f"opening: {opening}")
        
        # Check chat style mechanics (if applicable)
        chat_style = profile.get('chat_style', {})
        if chat_style:
            mechanics = chat_style.get('mechanics', {})
            
            # Check shortening/shorthand
            shortening = mechanics.get('shortening', [])
            if shortening:
                max_score += len(shortening) * 0.5
                for short_form in shortening:
                    if short_form.lower() in content_lower:
                        score += 0.5
                        matches.append(f"shorthand: {short_form}")
            
            # Check casing patterns
            casing = mechanics.get('casing', [])
            if casing:
                max_score += 2
                # Check for lowercase "i" (common in casual typing)
                if 'i ' in content_lower and 'I ' not in content:
                    score += 1
                    matches.append("lowercase_i")
                if 'im ' in content_lower or "i'm" in content_lower:
                    score += 1
                    matches.append("casual_contractions")
        
        # Check blog style structure (if applicable)
        blog_style = profile.get('blog_style', {})
        if blog_style:
            structure = blog_style.get('structure', {})
            required_headings = structure.get('required_headings', [])
            if required_headings:
                max_score += len(required_headings) * 1
                for heading in required_headings:
                    if heading in content:
                        score += 1
                        matches.append(f"heading: {heading}")
        
        # Check lexical themes
        themes = profile.get('lexical_themes', [])
        if themes:
            max_score += len(themes) * 1
            for theme in themes:
                theme_words = theme.lower().split(' / ')
                for word in theme_words:
                    if word.strip() in content_lower:
                        score += 0.5
                        matches.append(f"theme: {word.strip()}")
        
        # Calculate confidence (0-1 scale)
        confidence = score / max_score if max_score > 0 else 0.0
        
        return (confidence, {
            "score": score,
            "max_score": max_score,
            "confidence": confidence,
            "matches": matches,
            "match_count": len(matches)
        })
    
    def get_profile(self, profile_id: str) -> Optional[Dict]:
        """Get a specific voice profile by ID."""
        return self.profiles.get(profile_id)
    
    def list_profiles(self) -> List[str]:
        """List all available profile IDs."""
        return list(self.profiles.keys())
    
    def suggest_voice(self, content: str, context: str = "blog") -> str:
        """
        Suggest which voice profile to use based on content analysis.
        
        Args:
            content: Content to analyze
            context: "blog" or "chat" - determines which style to prioritize
        
        Returns:
            Suggested profile ID
        """
        profile_id, confidence, analysis = self.detect_voice(content)
        
        # If confidence is low, suggest based on context
        if confidence < 0.3:
            # Default suggestions based on context
            if context == "blog":
                # For blog posts, prefer structured voices
                if "victor" in self.profiles:
                    return "victor_v1"
                elif "kiki" in self.profiles:
                    return "kiki_v1"
            else:
                # For chat, prefer casual voices
                if "victor" in self.profiles:
                    return "victor_v1"
        
        return profile_id
    
    def analyze_content_authenticity(self, content: str) -> Dict:
        """
        Analyze how authentic/human the content appears.
        
        Returns:
            Analysis with authenticity score and recommendations
        """
        profile_id, confidence, analysis = self.detect_voice(content)
        
        authenticity_score = confidence
        
        # Additional checks for AI-generated patterns
        ai_indicators = []
        
        # Check for overly formal language
        formal_phrases = [
            "it is important to note",
            "in conclusion",
            "furthermore",
            "moreover",
            "it should be noted",
            "as previously mentioned"
        ]
        for phrase in formal_phrases:
            if phrase.lower() in content.lower():
                ai_indicators.append(f"formal_phrase: {phrase}")
                authenticity_score -= 0.1
        
        # Check for repetitive patterns
        sentences = content.split('.')
        if len(sentences) > 5:
            first_words = [s.strip().split()[0].lower() if s.strip() else "" 
                          for s in sentences[:10]]
            word_counts = Counter(first_words)
            if any(count > 3 for count in word_counts.values()):
                ai_indicators.append("repetitive_sentence_starts")
                authenticity_score -= 0.1
        
        # Check for natural variation
        if len(content) > 500:
            # Check sentence length variation
            sentence_lengths = [len(s.split()) for s in sentences if s.strip()]
            if sentence_lengths:
                avg_length = sum(sentence_lengths) / len(sentence_lengths)
                variation = max(sentence_lengths) - min(sentence_lengths)
                if variation < avg_length * 0.5:  # Too uniform
                    ai_indicators.append("uniform_sentence_lengths")
                    authenticity_score -= 0.1
        
        authenticity_score = max(0.0, min(1.0, authenticity_score))
        
        return {
            "detected_profile": profile_id,
            "confidence": confidence,
            "authenticity_score": authenticity_score,
            "analysis": analysis,
            "ai_indicators": ai_indicators,
            "recommendations": self._get_recommendations(authenticity_score, ai_indicators)
        }
    
    def _get_recommendations(self, score: float, indicators: List[str]) -> List[str]:
        """Get recommendations to improve authenticity."""
        recommendations = []
        
        if score < 0.5:
            recommendations.append("Content doesn't strongly match any voice profile")
            recommendations.append("Consider rewriting to match a specific voice profile")
        
        if indicators:
            recommendations.append("Detected AI-generated patterns:")
            recommendations.extend([f"  - {ind}" for ind in indicators])
            recommendations.append("Consider adding more natural variation")
        
        if score > 0.7:
            recommendations.append("Content matches voice profile well")
        
        return recommendations


def detect_voice_from_content(content: str, profiles_dir: Optional[Path] = None) -> Dict:
    """
    Convenience function to detect voice from content.
    
    Args:
        content: Content to analyze
        profiles_dir: Optional path to profiles directory
    
    Returns:
        Detection results
    """
    detector = VoiceDetector(profiles_dir)
    return detector.analyze_content_authenticity(content)


if __name__ == '__main__':
    """CLI interface for testing."""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: voice_detector.py <content_file>")
        sys.exit(1)
    
    content_file = Path(sys.argv[1])
    if not content_file.exists():
        print(f"‚ùå File not found: {content_file}")
        sys.exit(1)
    
    with open(content_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    detector = VoiceDetector()
    result = detector.analyze_content_authenticity(content)
    
    print("\n" + "="*60)
    print("VOICE DETECTION RESULTS")
    print("="*60)
    print(f"Detected Profile: {result['detected_profile']}")
    print(f"Confidence: {result['confidence']:.2%}")
    print(f"Authenticity Score: {result['authenticity_score']:.2%}")
    print(f"\nMatches Found: {result['analysis']['match_count']}")
    if result['analysis']['matches']:
        print("Matches:")
        for match in result['analysis']['matches'][:10]:
            print(f"  - {match}")
    
    if result['ai_indicators']:
        print(f"\n‚ö†Ô∏è  AI Indicators:")
        for indicator in result['ai_indicators']:
            print(f"  - {indicator}")
    
    if result['recommendations']:
        print(f"\nüí° Recommendations:")
        for rec in result['recommendations']:
            print(f"  {rec}")


